---
title       : Julia implementation of GFI
subtitle    : First part - the polyhedra sampler
author      : Stephane Laurent
job         : 
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
widgets     : [bootstrap, mathjax, scianimator]          
mode        : selfcontained # {standalone, draft}
---

```{r setup, echo=FALSE, cache=FALSE}
source("assets/R/slidifyMacros.R")
source('D:/Work/Fiducial/R/particle_01_functions.R')
library(knitr)
library(animation)
library(scales)
opts_chunk$set(fig.path="assets/fig/JuliaGFI00-")
hook_scianimator <- function (x, options) 
{
    fig.num = options$fig.num
    base = "" #opts_knit$get("base.url") %n% ""
    id = gsub("[^[:alnum:]]", "_", options$label)
    sprintf("\n<div class=\"scianimator\">\n<div id=\"%s\" style=\"display: inline-block;\">\n</div>\n</div>\n<script type=\"text/javascript\">\n  (function($) {\n    $(document).ready(function() {\n  %s\n    var imgs = Array(%s);\n      for (i=0; ; i++) {\n        if (i == imgs.length) break;\n        imgs[i] = \"%s%s\" + (i + 1) + \".%s\";\n      }\n      $(\"#%s\").scianimator({\n          \"images\": imgs,\n           \"controls\": [\"previous\",  \"next\"],\n \"keyboard\": false,\n \"loopmode\": \"none\",\n \"defaultFrame\": 0\n    });\n     });\n  })(jQuery);\n</script>\n", 
        id, id, fig.num, base, sub(stringr::str_c(fig.num, "$"), "", x[1]), 
        x[2], id, id)
}
assignInNamespace("hook_scianimator",hook_scianimator, ns="knitr")
opts_knit$set(animation.fun = hook_scianimator)
set.seed(666)
```

## Goal 

- Implement Ciszewski & Hannig's sampler of the fiducial distributino for normal linear mixed models

- *Why Julia ?* 

  - The algorithm is computationnaly intensive
  
  - It requires a high numerical precision; we hope the `BigFloat` type in Julia will achieve this precision 


---

## Problem addressed in these slides 

- These slides only address one part of the algorithm: the sampling of 
random polyhedra in the Euclidean space 

- This is the point requiring high numerical precision, because the 
polyhedra are sequentially sampled and become smaller and smaller and smaller...

- I'm not a Julia specialist; these slides should firstly help me to request some help


--- &twocolcustomwidth 

## Polyhedra construction: overview 

*** {name: left, width: "33%"}

- *Data:* Some pairs of points are given on the $y$-axis

- *Sampling:* Some ribbons issued from these points are sampled at random 

- *Computation:* The polyhedron at the intersection of the ribbons

*** {name: right, width: "63%"}

```{r construction_intro, echo=FALSE, cache=FALSE}
# init 
source("./assets/R/global.R")
D31["b"] <- D32["b"] <- 0.5 #runif(1,mM[1],mM[2])
part2 <- findVert(part, D31)
part2 <- findVert(part2, D32)
parttemp <- rbind(part,D31,D32)
parttemp[, "include"] <- 1
```


```{r construction_intro_plot00, echo=FALSE, fig.show='animate', cache=FALSE,  fig.height=5}
par(bg = "white")
xlim <- c(0,2)
ylim <- c(0,6.5)
#
plot(0, 0, type="n", xlim=xlim, ylim=ylim, axes=FALSE, 
     xaxs="i", yaxs="i", xlab="x", ylab="y", 
      main="Data")
 axis(1);axis(2)
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D31["a"], D32["a"]), col="red", pch=19, cex=2, xpd=TRUE)
# plot.new()
#
plotpart2(parttemp, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE, col.line=rep(c("blue","green", "red"),each=2), 
          main="Sampling of ribbons")
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D31["a"], D32["a"]), col="red", pch=19, cex=2, xpd=TRUE)
D1 <- D11
D2 <- D12
polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("blue",0.4), border=NA)
D1 <- D21
D2 <- D22
polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("green",0.4), border=NA)
D1 <- D31
D2 <- D32
polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("red",0.4), border=NA)
plot.new()
#
plotpart2(parttemp, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE,  col.line=rep(c("blue","green", "red"),each=2), 
          main="Polyhedron")
D1 <- D11
D2 <- D12
polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("blue",0.4), border=NA)
D1 <- D21
D2 <- D22
polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("green",0.4), border=NA)
D1 <- D31
D2 <- D32
polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("red",0.4), border=NA)
plotpart2(part2, lines=FALSE, add=TRUE, col.edge="black")
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D31["a"], D32["a"]), col="red", pch=19, cex=2, xpd=TRUE)
```


--- &twocolcustomwidth 

## Polyhedra construction: algorithm 

*** {name: left, width: "33%"}

- *Step 1:* the slopes of the first two pairs of lines are sampled without restriction

- *Step 2:* the polyhedron is computed

- *Step 3:* the slope of the next pair is sampled in a constrained range, assuring there's an intersection

- *Step 4*: the polyhedron is  updated

- *Repeat* steps 3 and 4

*** {name: right, width: "63%"}


```{r construction_intro_plot01, echo=FALSE, fig.show='animate', cache=FALSE,  fig.height=5, interval=.2}
par(bg = "white")
xlim <- c(0,2)
ylim <- c(0,6.5)
# #
# plot(0, 0, type="n", xlim=xlim, ylim=ylim, axes=FALSE, 
#      xaxs="i", yaxs="i", xlab="x", ylab="y", 
#       main="Data")
#  axis(1);axis(2)
# points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
# points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
# # plot.new()
# #
# plotpart2(part[part[,"pair"]==1,], xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE, 
#           main="Step1:")
# points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
# points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
# plot.new()
# #
# plotpart2(part, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE, 
#           main="Step2:")
# points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
# points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
# plot.new()
#
plotpart2(part, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE, 
          col.line=rep(c("blue","green"),each=2, col.edge="black"),
          main="Step 1:")
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
#
plotpart2(part, xlim=xlim, ylim=ylim, lines=TRUE, 
          col.line=rep(c("blue","green"),each=2), col.edge="black",
          main="Step 2:")
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
#
plotpart2(parttemp, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE,  col.line=rep(c("blue","green", "red"),each=2), 
          main="Step 3")
plotpart2(part, lines=FALSE, add=TRUE, col.edge="black")
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D31["a"], D32["a"]), col="red", pch=19, cex=2, xpd=TRUE)
#
plotpart2(parttemp, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE,  col.line=rep(c("blue","green", "red"),each=2), 
          main="Step 4")
plotpart2(part2, lines=FALSE, add=TRUE, col.edge="black" )
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D31["a"], D32["a"]), col="red", pch=19, cex=2, xpd=TRUE)
```


--- &twocolcustomwidth

## Line and polyhedron representation 

  - A line has a ''type'': upper or lower
  
  - A line has $0$, $1$ or $2$ intersections with the active polyhedron

*** {name: left, width: "60%"}

```{r line_plot01, echo=FALSE, fig.show='animate', cache=FALSE,  fig.height=5}
par(bg = "white")
plot0 <- function(){
  par(mar=c(1,1,0.1,1))
  plotpart2(part, xlim=xlim, ylim=ylim, lines=TRUE, 
          col.line=rep(c("blue","green"),each=2), col.edge="black",
          main="", xlab=NA, ylab=NA)
points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
}
plot0()
plot.new()
# 
plot0()
points(0, 1, col="red", pch=19, cex=2, xpd=TRUE)
abline(a=1, b=2.8, col="red", lwd=2)
plot.new()
# 
plot0()
points(0, 1, col="red", pch=19, cex=2, xpd=TRUE)
abline(a=1, b=0.96, col="red", lwd=2)
plot.new()
# 
plot0()
points(0, 1, col="red", pch=19, cex=2, xpd=TRUE)
abline(a=1, b=1.4, col="red", lwd=2)
```

*** {name: right, width: "40%"}

`r linebreak("30pt")`

- Only lines having two intersections are kept

- A polyhedron is represented by a set of such lines


--- &twocolcustomwidth

## Line and polyhedron in Julia  

I will firstly try to deal with lines and polyhedra using these types and macros:

*** {name: left, width: "60%"}

```{r type_line, results='asis', echo=FALSE}
codechunk("type Line
        a::Float64   # intercept
        b::BigFloat  # slope
        x1::BigFloat # x-coordinate of first vertice
        y1::BigFloat # y-coordinate of first vertice
        x2::BigFloat # x-coordinate of second vertice
        y2::BigFloat # y-coordinate of second vertice
        typ::Bool    # type of the line (true:upper, false:lower)
end", size="66%")
```

*** {name: right, width: "40%"}

```{r type_poly, results='asis', echo=FALSE}
codechunk("type Poly
        a::Vector{Float64}
        b::Vector{BigFloat}
        x1::Vector{BigFloat}
        y1::Vector{BigFloat}
        x2::Vector{BigFloat}
        y2::Vector{BigFloat}
        typ::Vector{Bool}
end", size="66%")
```

*** =fullwidth


```{r macro_addline, results='asis', echo=FALSE}
codechunk("macro addLine(poly, line)
        for op = (:a, :b, :x1, :y1, :x2, :y2, :typ)
          @eval $poly.$op = [$poly.$op, $line.$op]
        end
end", size="66%")
```

```{r macro_removeline, results='asis', echo=FALSE}
codechunk("macro removeLine(poly, index)
    for op = (:a, :b, :x1, :y1, :x2, :y2, :typ)
        @eval splice!($poly.$op, $index)
    end
end", size="66%")
```


--- 

## Computing the range and intersection 

Recall the two steps, when a particle and a new pair of starting points 
on the $y$-axis is given:

- Calculate the range of the possible slope of the new ribbon

- Generate the new ribbon and compute the new particle


```{r init_newribbon, echo=FALSE, cache=FALSE}
# init 
source("./assets/R/global.R")
seq.b <- seq(mM[1]*0.98, mM[2]*0.98, len=80)
```

```{r gif, echo=FALSE, message=FALSE, cache=FALSE}
if(!file.exists("./assets/img/range.gif")){
  saveGIF({
    for(b in c(seq.b, rev(seq.b))){
      D31["b"] <- D32["b"] <- b #runif(1,mM[1],mM[2])
      part2 <- findVert(part, D31)
      part2 <- findVert(part2, D32)
      parttemp <- rbind(part,D31,D32)
      parttemp[, "include"] <- 1
      par(bg = "white")
      xlim <- c(0,2)
      ylim <- c(0,6.5)
      #
        par(mar=c(3,3,1,1))
      plotpart2(parttemp, xlim=xlim, ylim=ylim, lines=TRUE, edges=FALSE, vertices=FALSE,  col.line=rep(c("blue","green", "red"),each=2), 
                main=NA)
      D1 <- D11
      D2 <- D12
      polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("blue",0.4), border=NA)
      D1 <- D21
      D2 <- D22
      polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("green",0.4), border=NA)
      D1 <- D31
      D2 <- D32
      polygon(x=c(0,0,xlim[2],xlim[2]), y=c(D1["a"], D2["a"], D2["a"]+D2["b"]*xlim[2], D1["a"]+D1["b"]*xlim[2]), col=alpha("red",0.4), border=NA)
      plotpart2(part2, lines=FALSE, add=TRUE, col.edge="black")
      points(c(0,0), c(D11["a"], D12["a"]), col="blue", pch=19, cex=2, xpd=TRUE)
      points(c(0,0), c(D21["a"], D22["a"]), col="green", pch=19, cex=2, xpd=TRUE)
      points(c(0,0), c(D31["a"], D32["a"]), col="red", pch=19, cex=2, xpd=TRUE)
      }
    }, movie.name = "range.gif", interval = 0.06, nmax = 30, ani.width = 600, 
    ani.height = 400, outdir=paste0(getwd(),"/assets/img"), autobrowse=FALSE)
  }
```

```{r, results='asis', echo=FALSE}
cat('<img src="assets/img/range.gif" title="plot of chunk xxx" alt="plot of chunk xxx" style="display: block; margin: auto;" width="55%">')
```



--- 

## Computing the range

Two different situations are considered for the range calculation:



